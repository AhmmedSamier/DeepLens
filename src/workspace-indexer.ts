import * as vscode from 'vscode';
import * as path from 'path';
import { SearchableItem, SearchItemType } from './core/types';
import { Config } from './config';

/**
 * Workspace indexer that scans files and extracts symbols
 */
export class WorkspaceIndexer {
    private items: SearchableItem[] = [];
    private indexing: boolean = false;
    private config: Config;
    private fileWatcher: vscode.FileSystemWatcher | undefined;

    constructor(config: Config) {
        this.config = config;
    }

    /**
   * Start indexing the workspace
   */
    async indexWorkspace(
        progressCallback?: (message: string, increment?: number) => void
    ): Promise<void> {
        if (this.indexing) {
            return;
        }

        this.indexing = true;
        this.items = [];

        try {
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders) {
                return;
            }

            // Index files
            progressCallback?.('Scanning workspace files...', 0);
            await this.indexFiles();

            // Index symbols from files
            await this.indexSymbols(progressCallback);

            // Set up file watchers for incremental updates
            this.setupFileWatchers();
        } finally {
            this.indexing = false;
        }
    }

    /**
     * Get all indexed items
     */
    getItems(): SearchableItem[] {
        return this.items;
    }

    /**
     * Check if indexing is in progress
     */
    isIndexing(): boolean {
        return this.indexing;
    }

    /**
     * Index all files in workspace
     */
    private async indexFiles(): Promise<void> {
        const excludePatterns = this.config.getExcludePatterns();
        const fileExtensions = this.config.getFileExtensions();
        const respectGitignore = this.config.shouldRespectGitignore();

        // Build glob patterns
        const includePattern = `**/*.{${fileExtensions.join(',')}}`;

        // VS Code's findFiles automatically respects:
        // 1. files.exclude setting
        // 2. .gitignore files (if respectGitignore is true, which is default)
        // 3. Our custom exclude patterns
        const excludePattern = `{${excludePatterns.join(',')}}`;

        // Note: VS Code respects .gitignore files by default when using workspace.findFiles
        // The search.useIgnoreFiles setting controls this (defaults to true)
        const files = await vscode.workspace.findFiles(includePattern, excludePattern);

        for (const file of files) {
            // Skip C# auto-generated files
            if (file.fsPath.endsWith('.cs')) {
                const isAutoGenerated = await this.isAutoGeneratedFile(file);
                if (isAutoGenerated) {
                    continue; // Skip this file
                }
            }

            const fileName = path.basename(file.fsPath);
            const relativePath = vscode.workspace.asRelativePath(file.fsPath);

            this.items.push({
                id: `file:${file.fsPath}`,
                name: fileName,
                type: SearchItemType.FILE,
                filePath: file.fsPath,
                detail: relativePath,
                fullName: relativePath,
            });
        }
    }

    /**
     * Check if a file is auto-generated (C# files with // <auto-generated /> marker)
     * Optimized to avoid opening a full VS Code document
     */
    private async isAutoGeneratedFile(fileUri: vscode.Uri): Promise<boolean> {
        try {
            // Read only first 1KB to check for marker - much faster than openTextDocument
            const buffer = await vscode.workspace.fs.readFile(fileUri);
            const content = Buffer.from(buffer.slice(0, 1024)).toString('utf8');

            if (!content) return false;

            const firstLine = content.split('\n')[0].trim();

            // Check for common auto-generated markers in C#
            return (
                firstLine === '// <auto-generated />' ||
                firstLine === '// <auto-generated/>' ||
                firstLine.startsWith('// <auto-generated>') ||
                content.includes('<auto-generated') // Some files have it later or in a header block
            );
        } catch (error) {
            return false;
        }
    }

    /**
     * Index symbols from all files with concurrency
     */
    private async indexSymbols(
        progressCallback?: (message: string, increment?: number) => void
    ): Promise<void> {
        const fileItems = this.items.filter((item) => item.type === SearchItemType.FILE);
        const totalFiles = fileItems.length;

        // Use a concurrency limit to avoid overwhelming language servers
        const concurrency = 10;
        const chunks: SearchableItem[][] = [];
        for (let i = 0; i < fileItems.length; i += concurrency) {
            chunks.push(fileItems.slice(i, i + concurrency));
        }

        let processed = 0;
        for (const chunk of chunks) {
            await Promise.all(chunk.map(async (fileItem) => {
                try {
                    await this.indexFileSymbols(vscode.Uri.file(fileItem.filePath));
                } catch (error) {
                    console.error(`Error indexing ${fileItem.filePath}:`, error);
                }
                processed++;

                if (processed % 5 === 0 || processed === totalFiles) {
                    const fileName = path.basename(fileItem.filePath);
                    progressCallback?.(
                        `Indexing ${fileName} (${processed}/${totalFiles})`,
                        (5 / totalFiles) * 100
                    );
                }
            }));
        }
    }

    /**
   * Index symbols from a single file
   */
    private async indexFileSymbols(fileUri: vscode.Uri): Promise<void> {
        try {
            // Use VS Code's DocumentSymbolProvider
            const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
                'vscode.executeDocumentSymbolProvider',
                fileUri
            );

            if (!symbols || symbols.length === 0) {
                // Try opening the document to trigger language server
                const document = await vscode.workspace.openTextDocument(fileUri);

                // Wait a bit for language server to process
                await new Promise(resolve => setTimeout(resolve, 200));

                // Try again
                const retrySymbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
                    'vscode.executeDocumentSymbolProvider',
                    fileUri
                );

                if (retrySymbols && retrySymbols.length > 0) {
                    this.processSymbols(retrySymbols, fileUri.fsPath);
                }
            } else {
                this.processSymbols(symbols, fileUri.fsPath);
            }
        } catch (error) {
            // Silently skip files without symbol support
            // Common for files where language server isn't available yet
            console.log(`Could not extract symbols from ${fileUri.fsPath}: ${error}`);
        }
    }

    /**
     * Process symbols recursively
     */
    private processSymbols(
        symbols: vscode.DocumentSymbol[],
        filePath: string,
        containerName?: string
    ): void {
        for (const symbol of symbols) {
            const itemType = this.mapSymbolKindToItemType(symbol.kind);
            if (itemType) {
                const fullName = containerName ? `${containerName}.${symbol.name}` : symbol.name;

                this.items.push({
                    id: `symbol:${filePath}:${fullName}:${symbol.range.start.line}`,
                    name: symbol.name,
                    type: itemType,
                    filePath,
                    line: symbol.range.start.line,
                    column: symbol.range.start.character,
                    containerName,
                    fullName,
                    detail: symbol.detail,
                });
            }

            // Process nested symbols
            if (symbol.children && symbol.children.length > 0) {
                const newContainerName = containerName ? `${containerName}.${symbol.name}` : symbol.name;
                this.processSymbols(symbol.children, filePath, newContainerName);
            }
        }
    }

    /**
     * Map VS Code SymbolKind to our SearchItemType
     */
    private mapSymbolKindToItemType(kind: vscode.SymbolKind): SearchItemType | null {
        switch (kind) {
            case vscode.SymbolKind.Class:
                return SearchItemType.CLASS;
            case vscode.SymbolKind.Interface:
                return SearchItemType.INTERFACE;
            case vscode.SymbolKind.Enum:
                return SearchItemType.ENUM;
            case vscode.SymbolKind.Function:
                return SearchItemType.FUNCTION;
            case vscode.SymbolKind.Method:
                return SearchItemType.METHOD;
            case vscode.SymbolKind.Property:
            case vscode.SymbolKind.Field:
                return SearchItemType.PROPERTY;
            case vscode.SymbolKind.Variable:
            case vscode.SymbolKind.Constant:
                return SearchItemType.VARIABLE;
            default:
                return null; // Skip other symbol kinds
        }
    }

    /**
     * Setup file watchers for incremental updates
     */
    private setupFileWatchers(): void {
        const fileExtensions = this.config.getFileExtensions();
        const pattern = `**/*.{${fileExtensions.join(',')}}`;

        this.fileWatcher = vscode.workspace.createFileSystemWatcher(pattern);

        // Handle file creation
        this.fileWatcher.onDidCreate((uri) => {
            this.handleFileCreated(uri);
        });

        // Handle file changes
        this.fileWatcher.onDidChange((uri) => {
            this.handleFileChanged(uri);
        });

        // Handle file deletion
        this.fileWatcher.onDidDelete((uri) => {
            this.handleFileDeleted(uri);
        });
    }

    /**
     * Handle file created
     */
    private async handleFileCreated(uri: vscode.Uri): Promise<void> {
        const fileName = path.basename(uri.fsPath);
        const relativePath = vscode.workspace.asRelativePath(uri.fsPath);

        // Add file item
        this.items.push({
            id: `file:${uri.fsPath}`,
            name: fileName,
            type: SearchItemType.FILE,
            filePath: uri.fsPath,
            detail: relativePath,
            fullName: relativePath,
        });

        // Index symbols
        await this.indexFileSymbols(uri);
    }

    /**
     * Handle file changed
     */
    private async handleFileChanged(uri: vscode.Uri): Promise<void> {
        // Remove old symbols for this file
        this.items = this.items.filter(
            (item) => item.filePath !== uri.fsPath || item.type === SearchItemType.FILE
        );

        // Re-index symbols
        await this.indexFileSymbols(uri);
    }

    /**
     * Handle file deleted
     */
    private handleFileDeleted(uri: vscode.Uri): void {
        // Remove all items for this file
        this.items = this.items.filter((item) => item.filePath !== uri.fsPath);
    }

    /**
     * Dispose resources
     */
    dispose(): void {
        this.fileWatcher?.dispose();
    }
}
